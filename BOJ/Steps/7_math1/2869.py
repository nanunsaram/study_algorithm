a, b, v = map(int, input().split())

# 마지막 날에는 반드시 a 이하의 거리를 이동하여 끝에 도달하고, 이 날은 b만큼 돌아가지 않는다.
# 따라서 마지막 날에 v 지점에 도착하기 위해서는, 그 날이 시작되기 직전에 있는 위치(p)가 v > p >= v-a여야 한다.

if (v-a) % (a-b) == 0:
    print((v-a)//(a-b)+1)
# 만약 (v-a)가 하루 낮과 밤을 이동하여 (a-b)만큼 이동하게 되는 시행으로 나누어 떨어진다면, 그 몫에 해당하는 날짜만큼 이동 후, 마지막 날 a를 이동하면 정확히 v에 맞게 도착한다. 그래서 몫 + 1로 계산한다.
# 이 때 혹시라도 이미 v에 도달하였는데 착오로 b로 돌아오는 연산을 했을 가능성은 없다. 낮과 밤을 이동하여 (a-b)만큼 이동하는 시행을 몇 번 마쳤더니 (v-a)에 도착했다고 할 때, 그 직전 밤에 b만큼 돌아온 것이고, 그 밤 전 낮에는 (v - a + b)라는 위치까지만 갈 수 있었기 때문이다.   
else:
    print(((v-a)//(a-b))+2)
# 만약 (v-a)가 (a-b)으로 나누어 떨어지지 않는다면, 그 몫에 해당하는 날짜만큼 이동하였을 때, 그 나머지라 할 수 있는 (a-b)보다 작은 거리와 더불어 남은 a만큼을 더 이동하여야 한다. 남은 거리(d)는 d < (a-b) + a이다.
# 따라서 하루 밤 낮을 이동(a-b)하고, 하루 낮을 더 이동하면 반드시 끝에 도달할 수 있다. 그래서 몫 + 2로 계산한다.
